<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delivery System Tester</title>
    <!-- Add Leaflet CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .field {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input,
        button,
        select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background-color: #45a049;
        }

        .log {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
        }

        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .delivery-item {
            padding: 10px;
            background-color: #f9f9f9;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }

        .delivery-item.accepted {
            border-left-color: #2196F3;
        }

        .delivery-item.picked_up {
            border-left-color: #FF9800;
        }

        .delivery-item.delivered {
            border-left-color: #9C27B0;
        }
        
        .delivery-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .delivery-controls select {
            flex: 2;
        }
        
        .delivery-controls button {
            flex: 1;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .refresh-button {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: auto;
        }

        /* Map styles */
        #locationMap {
            height: 300px;
            width: 100%;
            border-radius: 4px;
            margin-top: 10px;
        }

        .map-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .map-controls button {
            flex: 1;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="card">
            <h2>Delivery System Tester</h2>
            <p>Use this tool to test the delivery system functionality.</p>
        </div>

        <div class="card">
            <h3>Authentication</h3>
            <div class="field">
                <label for="authToken">JWT Token:</label>
                <input type="text" id="authToken" placeholder="Enter your JWT token">
            </div>
            <!-- Courier ID field removed as it's now extracted from JWT -->
            <button id="checkCourier">Check Courier Status</button>
        </div>

        <div class="card">
            <h3>Courier Availability</h3>
            <div class="field">
                <label>Availability:</label>
                <div style="display: flex; gap: 10px;">
                    <button id="setAvailable">Set Available</button>
                    <button id="setUnavailable">Set Unavailable</button>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>Order Assignment</h3>
            <div class="field">
                <label for="orderId">Order ID:</label>
                <input type="number" id="orderId" placeholder="Enter order ID">
            </div>
            <button id="assignDelivery">Assign for Delivery</button>
        </div>

        <div class="card">
            <h3>WebSocket Connection</h3>
            <div class="field">
                <p style="color: #666; margin-bottom: 10px;">
                    <strong>Note:</strong> Make sure to enter your Courier ID in the Authentication section above before
                    connecting.
                </p>
                <div style="display: flex; gap: 10px;">
                    <button id="connectWs">Connect</button>
                    <button id="disconnectWs">Disconnect</button>
                </div>
            </div>
            <div class="field">
                <label>Status: <span id="wsStatus">Disconnected</span></label>
            </div>
        </div>

        <div class="card">
            <h3>Delivery Actions</h3>
            <div class="field">
                <label for="actionDeliveryId">Delivery ID:</label>
                <input type="number" id="actionDeliveryId" placeholder="Enter delivery ID">
            </div>
            <div class="field">
                <label for="deliveryStatus">Update Status:</label>
                <select id="deliveryStatus">
                    <option value="accepted">Accept Delivery</option>
                    <option value="picked_up">Picked Up</option>
                    <option value="in_transit">In Transit</option>
                    <option value="delivered">Delivered</option>
                    <option value="failed">Failed</option>
                    <option value="canceled">Canceled</option>
                </select>
            </div>
            <button id="updateStatus">Update Status</button>
        </div>

        <!-- Add this new card for the map before the location simulator card -->
        <div class="card">
            <h3>Location Map</h3>
            <div id="locationMap"></div>
            <div class="map-controls">
                <button id="centerMap">Center Map</button>
                <button id="toggleMapFollow">Auto-Follow: ON</button>
            </div>
        </div>

        <div class="card">
            <h3>Location Simulator</h3>
            <div class="field">
                <label>Location Simulation:</label>
                <div style="display: flex; gap: 10px;">
                    <button id="startLocationSimulation">Start Simulation</button>
                    <button id="stopLocationSimulation">Stop Simulation</button>
                </div>
            </div>
            <div class="field">
                <label>Current Location: <span id="currentLocation">Not tracking</span></label>
            </div>
        </div>

        <div class="card">
            <div class="section-header">
                <h3>Active Deliveries</h3>
                <button id="refreshDeliveries" class="refresh-button">🔄 Refresh</button>
            </div>
            <div id="activeDeliveries">No active deliveries</div>
        </div>

        <div class="card">
            <h3>Log</h3>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        let ws = null;
        let locationInterval = null;
        let map = null;
        let courierMarker = null;
        let followMap = true;
        let extractedCourierId = null; // Added to store extracted courier ID
        const baseUrl = window.location.hostname === 'localhost' ?
            'http://localhost:3000/v1' :
            `${window.location.protocol}//${window.location.host}/v1`;
        const wsBaseUrl = window.location.hostname === 'localhost' ?
            'ws://localhost:3000/ws' :
            `ws://${window.location.host}/ws`;

        // Initialize map
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize map with Stockholm (default location)
            map = L.map('locationMap').setView([59.3293, 18.0686], 13);
            
            // Add OpenStreetMap tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Initialize courier marker (hidden at first)
            courierMarker = L.marker([0, 0], {
                icon: L.divIcon({
                    className: 'courier-marker',
                    html: '🚚',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            });

            // Map control buttons
            document.getElementById('centerMap').addEventListener('click', function() {
                if (courierMarker && courierMarker.getLatLng()) {
                    map.setView(courierMarker.getLatLng(), 15);
                }
            });

            document.getElementById('toggleMapFollow').addEventListener('click', function() {
                followMap = !followMap;
                this.textContent = followMap ? 'Auto-Follow: ON' : 'Auto-Follow: OFF';
                log(`Map auto-follow ${followMap ? 'enabled' : 'disabled'}`);
            });

            log('Map initialized');
        });

        // Helper functions
        function log(message, data = null) {
            const logElement = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            let content = `${new Date().toLocaleTimeString()}: ${message}`;
            if (data) {
                content += '<br>' + JSON.stringify(data, null, 2);
            }

            entry.innerHTML = content;
            logElement.prepend(entry);
        }

        function getToken() {
            return document.getElementById('authToken').value;
        }

        function getCourierId() {
            // Extract courier ID from JWT if not already extracted
            if (!extractedCourierId) {
                try {
                    // Try to extract from JWT
                    const token = getToken();
                    if (token) {
                        // Parse JWT (get payload from middle part)
                        const parts = token.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            if (payload.sub || payload.courier_id) {
                                extractedCourierId = payload.sub || payload.courier_id;
                                log('Extracted courier ID from token', extractedCourierId);
                            }
                        }
                    }
                } catch (error) {
                    log('Error extracting courier ID from token', error.message);
                }
            }
            return extractedCourierId;
        }

        async function apiCall(endpoint, method = 'GET', body = null) {
            try {
                const options = {
                    method,
                    headers: {
                        'Authorization': `Bearer ${getToken()}`
                    }
                };

                if (body || method === 'POST' || method === 'PUT' || method === 'PATCH') {
                    options.headers['Content-Type'] = 'application/json';
                    options.body = JSON.stringify(body || {});
                }

                const response = await fetch(`${baseUrl}${endpoint}`, options);
                const data = await response.json();

                return { success: response.ok, status: response.status, data };
            } catch (error) {
                log('API Error', error.message);
                return { success: false, error: error.message };
            }
        }

        // New function to update delivery status directly from cards
        async function updateDeliveryStatus(deliveryId, status) {
            if (!deliveryId) {
                log('Error: Invalid delivery ID');
                return;
            }
            
            let result;
            
            try {
                // Use PATCH endpoint for all status updates for consistency
                result = await apiCall(`/deliveries/${deliveryId}/status`, 'PATCH', { status });
                log(`Update delivery ${deliveryId} status to ${status}`, result);
                
                if (result.success) {
                    // Update the UI to reflect the change
                    const deliveryItem = document.getElementById(`delivery-${deliveryId}`);
                    if (deliveryItem) {
                        // Update status class
                        deliveryItem.className = `delivery-item ${status}`;
                        
                        // Update status label
                        const statusLabel = deliveryItem.querySelector('.status-label');
                        if (statusLabel) statusLabel.textContent = status;
                        
                        // If it's a final status, remove the controls
                        if (['delivered', 'failed', 'canceled'].includes(status)) {
                            const controls = deliveryItem.querySelector('.delivery-controls');
                            if (controls) controls.remove();
                        } else {
                            // Otherwise update the controls with new relevant options
                            refreshDeliveryControls(deliveryId, status);
                        }
                    }
                }
            } catch (error) {
                log(`Error updating delivery ${deliveryId} status:`, error.message);
            }
        }

        // Function to refresh the controls for a specific delivery
        function refreshDeliveryControls(deliveryId, status) {
            const controls = document.querySelector(`#delivery-${deliveryId} .delivery-controls`);
            if (!controls) return;
            
            const select = controls.querySelector('select');
            if (!select) return;
            
            // Clear existing options
            select.innerHTML = '';
            
            // Add appropriate options based on current status
            switch(status) {
                case 'assigned':
                    select.innerHTML = `
                        <option value="accepted">Accept Delivery</option>
                        <option value="canceled">Cancel</option>
                    `;
                    break;
                case 'accepted':
                    select.innerHTML = `
                        <option value="picked_up">Picked Up</option>
                        <option value="canceled">Cancel</option>
                    `;
                    break;
                case 'picked_up':
                    select.innerHTML = `
                        <option value="in_transit">In Transit</option>
                        <option value="delivered">Delivered</option>
                        <option value="failed">Failed</option>
                    `;
                    break;
                case 'in_transit':
                    select.innerHTML = `
                        <option value="delivered">Delivered</option>
                        <option value="failed">Failed</option>
                    `;
                    break;
            }
        }

        function updateActiveDeliveries(deliveries = []) {
            const container = document.getElementById('activeDeliveries');

            if (!deliveries.length) {
                container.innerHTML = 'No active deliveries';
                return;
            }

            // Filter to only show active deliveries (not completed)
            const activeDeliveries = deliveries.filter(delivery => 
                !['delivered', 'failed', 'canceled'].includes(delivery.status)
            );
            
            if (activeDeliveries.length === 0) {
                container.innerHTML = 'No active deliveries - you are available for new assignments';
                return;
            }

            container.innerHTML = '';
            activeDeliveries.forEach(delivery => {
                // Map API response fields to expected UI fields
                const deliveryId = delivery.id || delivery.delivery_id || 0;
                const orderId = delivery.order_id || 0;
                const status = delivery.status || 'unknown';
                const restaurantName = delivery.restaurant_name || 'Restaurant info not available';
                const restaurantAddress = delivery.restaurant_address || 'Address not available';
                const customerAddress = delivery.customer_address || 'Customer address not available';
                
                const item = document.createElement('div');
                item.className = `delivery-item ${status}`;
                item.id = `delivery-${deliveryId}`;

                // Status options based on current status
                let statusOptions = '';
                
                switch(status) {
                    case 'assigned':
                        statusOptions = `
                            <option value="accepted">Accept Delivery</option>
                            <option value="canceled">Cancel</option>
                        `;
                        break;
                    case 'accepted':
                        statusOptions = `
                            <option value="picked_up">Picked Up</option>
                            <option value="canceled">Cancel</option>
                        `;
                        break;
                    case 'picked_up':
                        statusOptions = `
                            <option value="in_transit">In Transit</option>
                            <option value="delivered">Delivered</option>
                            <option value="failed">Failed</option>
                        `;
                        break;
                    case 'in_transit':
                        statusOptions = `
                            <option value="delivered">Delivered</option>
                            <option value="failed">Failed</option>
                        `;
                        break;
                    default:
                        statusOptions = `<option value="${status}">${status}</option>`;
                }

                item.innerHTML = `
                    <h4>Delivery #${deliveryId} (Order #${orderId})</h4>
                    <p><strong>Status:</strong> <span class="status-label">${status}</span></p>
                    <p><strong>Restaurant:</strong> ${restaurantName}</p>
                    <p><strong>Restaurant Address:</strong> ${restaurantAddress}</p>
                    <p><strong>Customer Address:</strong> ${customerAddress}</p>
                `;
                
                // Only add controls if the delivery isn't in a final state
                if (!['delivered', 'failed', 'canceled'].includes(status)) {
                    const controls = document.createElement('div');
                    controls.className = 'delivery-controls';
                    controls.innerHTML = `
                        <select class="status-select" id="status-select-${deliveryId}">
                            ${statusOptions}
                        </select>
                        <button class="update-status-btn" data-delivery-id="${deliveryId}">Update Status</button>
                    `;
                    item.appendChild(controls);
                }

                container.appendChild(item);
            });
            
            // Add event listeners to all update buttons
            document.querySelectorAll('.update-status-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const deliveryId = this.getAttribute('data-delivery-id');
                    const statusSelect = document.getElementById(`status-select-${deliveryId}`);
                    const status = statusSelect.value;
                    
                    // Also update the actionDeliveryId field with this delivery ID
                    document.getElementById('actionDeliveryId').value = deliveryId;
                    
                    updateDeliveryStatus(deliveryId, status);
                });
            });
        }
        
        // Event handlers
        document.getElementById('checkCourier').addEventListener('click', async function () {
            if (!getToken()) {
                log('Error: Please enter a JWT token');
                return;
            }

            const result = await apiCall('/courier/deliveries');
            log('Courier status check', result);
            
            // If successful, try to extract courier ID from response if available
            if (result.success && result.data && result.data.courier_id) {
                extractedCourierId = result.data.courier_id;
                log('Updated courier ID from API response', extractedCourierId);
            }
        });

        document.getElementById('setAvailable').addEventListener('click', async function () {
            const result = await apiCall('/courier/availability', 'POST', {
                is_available: true,
                is_working: true
            });
            log('Set courier available', result);
        });

        document.getElementById('setUnavailable').addEventListener('click', async function () {
            const result = await apiCall('/courier/availability', 'POST', {
                is_available: false,
                is_working: false
            });
            log('Set courier unavailable', result);
        });

        document.getElementById('assignDelivery').addEventListener('click', async function () {
            const orderId = document.getElementById('orderId').value;
            if (!orderId) {
                log('Error: Please enter an order ID');
                return;
            }

            const result = await apiCall(`/orders/${orderId}/delivery`, 'POST');
            log('Assign delivery', result);

            if (result.success) {
                document.getElementById('actionDeliveryId').value = result.data.deliveryId;
                log('Delivery assigned', {
                    deliveryId: result.data.deliveryId,
                    message: result.data.message
                });
            }
        });

        // Update the main form button handler to use the same logic
        document.getElementById('updateStatus').addEventListener('click', async function () {
            const deliveryIdField = document.getElementById('actionDeliveryId');
            const deliveryId = deliveryIdField.value.trim();
            const status = document.getElementById('deliveryStatus').value;

            if (!deliveryId) {
                log('Error: Please enter a delivery ID');
                // Highlight the field in red to make it obvious
                deliveryIdField.style.border = '2px solid red';
                setTimeout(() => {
                    deliveryIdField.style.border = '1px solid #ddd';
                }, 3000);
                return;
            }

            // Convert to number to ensure it's valid
            const deliveryIdNum = parseInt(deliveryId, 10);
            if (isNaN(deliveryIdNum)) {
                log('Error: Delivery ID must be a valid number');
                return;
            }

            // Use the same updateDeliveryStatus function for consistency
            await updateDeliveryStatus(deliveryIdNum, status);
        });

        document.getElementById('connectWs').addEventListener('click', function () {
            const token = getToken();

            if (!token) {
                log('Error: Authentication token required for WebSocket connection');
                document.getElementById('authToken').focus();
                document.getElementById('authToken').style.border = '2px solid red';
                setTimeout(() => {
                    document.getElementById('authToken').style.border = '1px solid #ddd';
                }, 3000);
                return;
            }

            // Clear previous connection
            if (ws) {
                ws.close();
            }

            try {
                document.getElementById('wsStatus').textContent = 'Connecting...';
                document.getElementById('wsStatus').style.color = 'blue';

                // Improved WebSocket URL construction - let server extract courier ID from token
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = window.location.hostname === 'localhost' ?
                    `ws://localhost:3000/ws/delivery?token=${encodeURIComponent(token)}` :
                    `${wsProtocol}//${window.location.host}/ws/delivery?token=${encodeURIComponent(token)}`;

                log(`Connecting to WebSocket at: ${wsUrl}`);
                ws = new WebSocket(wsUrl);

                // Set connection timeout
                const connectionTimeout = setTimeout(() => {
                    if (ws && ws.readyState !== WebSocket.OPEN) {
                        log('WebSocket connection timeout - server not responding');
                        document.getElementById('wsStatus').textContent = 'Timeout';
                        document.getElementById('wsStatus').style.color = 'red';
                        ws.close();
                    }
                }, 5000);

                ws.onopen = function () {
                    clearTimeout(connectionTimeout);
                    document.getElementById('wsStatus').textContent = 'Connected';
                    document.getElementById('wsStatus').style.color = 'green';
                    log('WebSocket connected successfully');
                };

                ws.onmessage = function (event) {
                    const message = JSON.parse(event.data);
                    log('WebSocket message received', message);

                    // Handle different event types
                    switch (message.event) {
                        case 'delivery_assigned':
                        case 'delivery_assigned_auto': // Add new event handler for auto-assigned deliveries
                            log('New delivery assigned' + (message.event === 'delivery_assigned_auto' ? ' (auto-accepted)' : ''), message.data);
                            if (message.data.courier_id === getCourierId()) {
                                // This delivery is assigned to this courier
                                log('This delivery is assigned to you', message.data);
                                
                                // Automatically refresh delivery list
                                apiCall('/courier/deliveries').then(result => {
                                    if (result.success && Array.isArray(result.data)) {
                                        updateActiveDeliveries(result.data);
                                    }
                                });
                            }
                            break;
                            
                        case 'courier_active_deliveries':
                            log('Active deliveries received', message.data);
                            if (Array.isArray(message.data) && message.data.length > 0) {
                                updateActiveDeliveries(message.data);
                            }
                            break;
                            
                        case 'courier_available_for_delivery':
                            log('Courier is now available for new deliveries', message.data);
                            
                            // Visual indicator that you're available
                            const deliveriesContainer = document.getElementById('activeDeliveries');
                            if (deliveriesContainer && deliveriesContainer.innerHTML.indexOf('active') === -1) {
                                deliveriesContainer.innerHTML = '<div style="background-color:#e7f7e7;padding:10px;border-left:4px solid #4CAF50;border-radius:4px;">' +
                                    '<strong>✅ You are available for new deliveries</strong></div>' + 
                                    (deliveriesContainer.innerHTML === 'No active deliveries' ? '' : deliveriesContainer.innerHTML);
                            }
                            
                            // Play a sound to notify the courier (optional)
                            try {
                                const audio = new Audio('/sounds/notification.mp3');
                                audio.play().catch(e => console.log('Could not play notification sound', e));
                            } catch (e) {
                                // Ignore audio errors
                            }
                            break;
                        
                        case 'delivery_status_update':
                            const status = message.data.status;
                            
                            // If a delivery was completed and this courier is available for new assignments
                            if (['delivered', 'failed', 'canceled'].includes(status) && 
                                message.data.courierAvailableForNewDeliveries) {
                                
                                log('Delivery completed, courier available for new assignments');
                                
                                // Refresh deliveries list
                                apiCall('/courier/deliveries').then(result => {
                                    if (result.success) {
                                        updateActiveDeliveries(result.data);
                                    }
                                });
                            }
                            break;
                        
                        // ...keep existing cases...
                    }
                };

                ws.onclose = function () {
                    document.getElementById('wsStatus').textContent = 'Disconnected';
                    document.getElementById('wsStatus').style.color = 'red';
                    log('WebSocket connection closed');
                };

                ws.onerror = function (error) {
                    document.getElementById('wsStatus').textContent = 'Error';
                    document.getElementById('wsStatus').style.color = 'red';
                    log('WebSocket error', error);
                };
            } catch (err) {
                log('Error connecting to WebSocket', err.message);
                document.getElementById('wsStatus').textContent = 'Failed';
                document.getElementById('wsStatus').style.color = 'red';
            }
        });

        document.getElementById('disconnectWs').addEventListener('click', function () {
            if (ws) {
                ws.close();
                ws = null;
                document.getElementById('wsStatus').textContent = 'Disconnected';
                document.getElementById('wsStatus').style.color = 'red';
                log('WebSocket disconnected');
            }
        });

        document.getElementById('startLocationSimulation').addEventListener('click', function () {
            if (!ws) {
                log('Error: Please connect WebSocket first');
                return;
            }

            if (locationInterval) {
                clearInterval(locationInterval);
            }

            // Show that we're requesting permissions
            document.getElementById('currentLocation').textContent = 'Requesting permission...';
            document.getElementById('currentLocation').style.color = 'blue';
            
            log('Requesting location permission from browser...');

            // Ask for browser's geolocation
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    // Success callback
                    function (position) {
                        document.getElementById('currentLocation').style.color = '';
                        // Use real coordinates as starting point
                        let lat = position.coords.latitude;
                        let lng = position.coords.longitude;
                        
                        log('✅ Got browser location successfully', { 
                            latitude: lat, 
                            longitude: lng,
                            accuracy: `${position.coords.accuracy} meters`
                        });
                        
                        document.getElementById('currentLocation').textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;

                        // Update map with real location
                        updateMapLocation(lat, lng);
                        
                        // Send initial location
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                event: 'update_location',
                                data: { latitude: lat, longitude: lng }
                            }));
                            log('Sent initial location to server');
                        }

                        // Start the simulation with slight variations from real location
                        locationInterval = setInterval(() => {
                            // Add a small random variation (±100m)
                            lat += (Math.random() * 0.002) - 0.001;
                            lng += (Math.random() * 0.002) - 0.001;

                            document.getElementById('currentLocation').textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                            
                            // Update map with new simulated location
                            updateMapLocation(lat, lng);

                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    event: 'update_location',
                                    data: { latitude: lat, longitude: lng }
                                }));
                            }
                        }, 5000); // Update every 5 seconds
                        
                        log('Location simulation started with real coordinates');
                    },
                    // Error callback with more detailed error information
                    function (error) {
                        document.getElementById('currentLocation').style.color = 'red';
                        
                        // Translate error codes to human-readable messages
                        let errorMessage;
                        switch(error.code) {
                            case 1: // PERMISSION_DENIED
                                errorMessage = 'You denied location permission. Please check your browser settings.';
                                document.getElementById('currentLocation').textContent = 'Permission denied';
                                break;
                            case 2: // POSITION_UNAVAILABLE
                                errorMessage = 'Location information is unavailable on this device.';
                                document.getElementById('currentLocation').textContent = 'Location unavailable';
                                break;
                            case 3: // TIMEOUT
                                errorMessage = 'Location request timed out. Please try again.';
                                document.getElementById('currentLocation').textContent = 'Request timeout';
                                break;
                            default:
                                errorMessage = 'Unknown error occurred getting your location.';
                                document.getElementById('currentLocation').textContent = 'Location error';
                        }
                        
                        log('⚠️ Geolocation error', {
                            code: error.code,
                            description: errorMessage,
                            message: error.message
                        });
                        
                        // Reset color after a moment
                        setTimeout(() => {
                            document.getElementById('currentLocation').style.color = '';
                        }, 3000);

                        // Fall back to default location (Stockholm)
                        let lat = 59.3293;
                        let lng = 18.0686;

                        log('Using fallback location (Stockholm)', { latitude: lat, longitude: lng });
                        document.getElementById('currentLocation').textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} (fallback)`;

                        // Update map with fallback location
                        updateMapLocation(lat, lng);

                        // Continue with simulation using default coordinates
                        locationInterval = setInterval(() => {
                            lat += (Math.random() * 0.002) - 0.001;
                            lng += (Math.random() * 0.002) - 0.001;

                            document.getElementById('currentLocation').textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} (fallback)`;
                            
                            // Update map with new simulated location
                            updateMapLocation(lat, lng);

                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    event: 'update_location',
                                    data: { latitude: lat, longitude: lng }
                                }));
                            }
                        }, 5000);
                    },
                    // Options with longer timeout
                    {
                        enableHighAccuracy: true,
                        timeout: 10000, // Increased timeout to 10 seconds
                        maximumAge: 0
                    }
                );
            } else {
                log('Error: Geolocation is not supported by this browser');
                document.getElementById('currentLocation').textContent = 'Not supported';
                document.getElementById('currentLocation').style.color = 'red';
                
                // Fall back to Stockholm coordinates
                let lat = 59.3293;
                let lng = 18.0686;
                
                log('Using fallback location (Stockholm)', { latitude: lat, longitude: lng });
                document.getElementById('currentLocation').textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} (fallback)`;
                
                // Update map with fallback location
                updateMapLocation(lat, lng);
                
                locationInterval = setInterval(() => {
                    lat += (Math.random() * 0.002) - 0.001;
                    lng += (Math.random() * 0.002) - 0.001;
                    
                    document.getElementById('currentLocation').textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} (fallback)`;
                    
                    // Update map with new simulated location
                    updateMapLocation(lat, lng);
                    
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            event: 'update_location',
                            data: { latitude: lat, longitude: lng }
                        }));
                    }
                }, 5000);
            }
        });

        // Function to update map location
        function updateMapLocation(lat, lng) {
            if (!map) return;
            
            const position = L.latLng(lat, lng);
            
            // Add marker if it doesn't exist on map yet
            if (!map.hasLayer(courierMarker)) {
                courierMarker.setLatLng(position).addTo(map);
                map.setView(position, 15);
            } else {
                // Update existing marker position
                courierMarker.setLatLng(position);
                
                // Center map on courier if follow is enabled
                if (followMap) {
                    map.setView(position);
                }
            }
        }

        document.getElementById('stopLocationSimulation').addEventListener('click', function () {
            if (locationInterval) {
                clearInterval(locationInterval);
                locationInterval = null;
                document.getElementById('currentLocation').textContent = 'Not tracking';
                log('Location simulation stopped');
            }
        });

        // Global function for accepting deliveries from UI
        window.acceptDeliveryFromUI = function (deliveryId) {
            document.getElementById('actionDeliveryId').value = deliveryId;
            document.getElementById('deliveryStatus').value = 'accepted';
            document.getElementById('updateStatus').click();
        };

        // Initialize - load active deliveries
        document.addEventListener('DOMContentLoaded', async function () {
            const token = localStorage.getItem('authToken');
            if (token) {
                document.getElementById('authToken').value = token;

                // Try to extract courier ID from token
                getCourierId();

                // Try to load active deliveries
                const result = await apiCall('/courier/deliveries');
                if (result.success && Array.isArray(result.data)) {
                    updateActiveDeliveries(result.data);
                    
                    // Update courier ID if available in response
                    if (result.data && result.data.length > 0 && result.data[0].courier_id) {
                        extractedCourierId = result.data[0].courier_id;
                    }
                }
            }
        });

        

        // Save token for convenience
        document.getElementById('authToken').addEventListener('change', function () {
            localStorage.setItem('authToken', this.value);
        });

        
    </script>
</body>

</html>